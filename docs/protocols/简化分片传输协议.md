# BLE 简化分片传输协议

> **版本**: 1.0（简化版）  
> **日期**: 2025-11-20  
> **状态**: ✅ 已实现并测试

## 📋 协议概述

使用**简单分片**机制传输大数据，无需复杂的分包协议头。设备端通过**换行符**或**完整 JSON** 自动识别消息边界。

## 🎯 设计原则

1. **简单性**: 无协议头，只传输纯数据
2. **自动重组**: 设备端自动累积和重组
3. **兼容性**: 与现有设备端代码完美兼容
4. **可靠性**: 使用消息结束标记确保完整性

## 📦 协议格式

### App 端发送

```
┌─────────────────────────────────────────┐
│  JSON 数据 + \n                         │
│  (可能被分成多个片段发送)                │
└─────────────────────────────────────────┘
```

**示例**：
```json
{"cmd":"set_wake_words","data":{...}}\n
```

### 分片规则

| 数据大小 | 处理方式 | 说明 |
|---------|---------|------|
| ≤ 240 字节 | 直接发送 | 单个 BLE 写入 |
| > 240 字节 | 分片发送 | 每片 240 字节 + 50ms 延迟 |

**分片示例**（350 字节数据）：
```
片1: {"cmd":"set_wake_words","data":{"words":[...（240字节）
  ↓ 延迟 50ms
片2: ...],"threshold":0.15,"replace":true}}\n（110字节）
```

## 🔄 工作流程

### App 端流程

```dart
// 1. 生成 JSON + 添加换行符
final jsonString = jsonEncode(command);
final jsonWithEnd = jsonString + '\n';
final data = utf8.encode(jsonWithEnd);

// 2. 判断是否需要分片
if (data.length <= 240) {
  // 直接发送
  await characteristic.write(data);
} else {
  // 分片发送
  for (每 240 字节) {
    await characteristic.write(片段);
    await Future.delayed(Duration(milliseconds: 50));
  }
}
```

### 设备端流程

```cpp
// 1. 接收数据片段
void gatt_svr_chr_access(data, len) {
  ProcessReceivedData(data);
}

// 2. 累积到缓冲区
void ProcessReceivedData(data) {
  receive_buffer_ += data;
  
  // 3. 查找换行符（消息结束标记）
  if (found '\n') {
    // 提取完整消息
    complete_message = receive_buffer_.substr(0, newline_pos);
    
    // 处理消息
    ProcessCommand(complete_message);
    
    // 清除已处理的数据
    receive_buffer_.erase(0, newline_pos + 1);
  }
}
```

## 📊 时序图

```
App 端                     ESP32 设备端
  │                              │
  │  片1: {"cmd":"set_...        │
  ├──────────────────────────────>│
  │                              │ → receive_buffer_ += 片1
  │                              │   (无 \n，等待更多数据)
  │      延迟 50ms               │
  │                              │
  │  片2: ...}}\n                │
  ├──────────────────────────────>│
  │                              │ → receive_buffer_ += 片2
  │                              │   (找到 \n，提取完整消息)
  │                              │ → ProcessCommand(...)
  │                              │
  │  {"status":"success"}        │
  │<──────────────────────────────┤
  │                              │
```

## ✅ 关键特性

### 1. 消息边界识别

设备端支持两种方式识别完整消息：

**方式 1**: 换行符（推荐）
```json
{"cmd":"get_wake_words"}\n
```

**方式 2**: 完整 JSON
- 以 `{` 开头
- 以 `}` 结尾
- 无换行符时的备用方案

### 2. 自动缓冲区管理

```cpp
// 累积数据
receive_buffer_ += new_data;

// 查找并提取完整消息
while (find '\n') {
  process_message();
  remove_processed_data();
}

// 防止溢出
if (buffer_size > 4096) {
  clear_buffer();
  log_error();
}
```

### 3. 容错机制

| 场景 | 处理 |
|------|------|
| 缓冲区过大 (>4KB) | 清空并记录错误 |
| 连接断开 | 自动清空缓冲区 |
| 不完整数据 | 保留在缓冲区，等待下一片 |

## 🧪 测试用例

### 测试 1: 小数据包（直接发送）

```dart
// App 发送
{"cmd":"get_wake_words"}\n  // 24 字节

// 设备接收
[片1] 24 字节 → 找到 \n → 处理完成 ✅
```

### 测试 2: 中等数据包（双片）

```dart
// App 发送
{"cmd":"set_wake_words","data":{...}}\n  // 300 字节

// 设备接收
[片1] 240 字节 → 无 \n，继续等待
[片2] 60 字节（含 \n）→ 找到 \n → 处理完成 ✅
```

### 测试 3: 大数据包（多片）

```dart
// App 发送
{"cmd":"set_wake_words","data":{...}}\n  // 500 字节

// 设备接收
[片1] 240 字节 → 累积
[片2] 240 字节 → 累积
[片3] 20 字节（含 \n）→ 找到 \n → 处理完成 ✅
```

## 📐 参数配置

### App 端参数

```dart
const int maxChunkSize = 240;          // 每片最大 240 字节
const int chunkDelayMs = 50;           // 片间延迟 50 毫秒
const String messageTerminator = '\n'; // 消息结束标记
```

### 设备端参数

```cpp
#define MAX_BUFFER_SIZE 4096     // 最大缓冲区 4KB
#define CHUNK_DELAY_MS 10        // 发送延迟 10ms
```

## 🔍 调试日志

### App 端日志

```
[BLE WiFi] 发送数据长度: 300 字节（含结束符）
[BLE WiFi] JSON内容: {"cmd":"set_wake_words",...}
[BLE WiFi] 数据过大，启用分片传输: 300 字节
[BLE WiFi] ┌─ 分片传输开始 ─────────────
[BLE WiFi] │ 总大小: 300 字节
[BLE WiFi] │ 分片数: 2
[BLE WiFi] │ 发送第 1/2 片: 240 字节
[BLE WiFi] │ 发送第 2/2 片: 60 字节
[BLE WiFi] └─ 分片传输完成 ─────────────
[BLE WiFi] ✓ 成功发送 2 个分片
```

### 设备端日志

```
[BluetoothService] 收到数据片段 (长度: 240)
[BluetoothService] 累积缓冲区大小: 240 字节
[BluetoothService] 等待更多数据...

[BluetoothService] 收到数据片段 (长度: 60)
[BluetoothService] 累积缓冲区大小: 300 字节
[BluetoothService] ========================================
[BluetoothService] 📦 接收到完整消息（带换行符）
[BluetoothService] 消息长度: 299 字节
[BluetoothService] 消息内容: {"cmd":"set_wake_words",...}
[BluetoothService] ========================================
```

## ⚠️ 注意事项

### 1. 换行符必须存在
- App 端**必须**在 JSON 后添加 `\n`
- 这是设备端识别消息完整的主要方式

### 2. 分片延迟重要
- 50ms 延迟确保设备端有时间处理每一片
- 过快发送可能导致数据丢失

### 3. 缓冲区大小限制
- 设备端最大缓冲区 4KB
- 单个命令不应超过此限制

### 4. 数据完整性
- BLE 写入使用 `withoutResponse: false`
- 确保每片都成功写入后才发送下一片

## 📈 性能指标

| 指标 | 值 |
|------|-----|
| 单片大小 | 240 字节 |
| 片间延迟 | 50 毫秒 |
| 双片传输耗时 | ~100 毫秒 |
| 三片传输耗时 | ~150 毫秒 |
| 最大支持数据 | ~4000 字节 |

## ✨ 优势

1. **简单**: 无需复杂的协议头
2. **可靠**: 基于换行符的明确边界
3. **高效**: 自动重组，无额外开销
4. **兼容**: 完全兼容现有设备端代码
5. **灵活**: 支持任意大小的 JSON 数据

## 🆚 对比复杂协议

| 特性 | 简化协议 | 复杂协议（带头部） |
|------|---------|-------------------|
| 实现难度 | ⭐ 简单 | ⭐⭐⭐ 复杂 |
| 代码行数 | ~50 行 | ~200 行 |
| 协议开销 | 0 字节 | 2 字节/片 |
| 调试难度 | ⭐ 容易 | ⭐⭐ 中等 |
| 设备端改动 | ❌ 无需改动 | ✅ 需要重写 |

## 🎯 最佳实践

### App 端

```dart
// ✅ 正确：添加换行符
final json = jsonEncode(data) + '\n';

// ❌ 错误：忘记换行符
final json = jsonEncode(data);

// ✅ 正确：检查数据大小
if (data.length > 4000) {
  throw Exception('数据过大');
}

// ✅ 正确：添加延迟
await Future.delayed(Duration(milliseconds: 50));
```

### 设备端

```cpp
// ✅ 正确：累积数据
receive_buffer_ += new_data;

// ✅ 正确：查找换行符
if (receive_buffer_.find('\n') != std::string::npos) {
  process_message();
}

// ✅ 正确：防止溢出
if (receive_buffer_.length() > 4096) {
  receive_buffer_.clear();
}
```

## 📞 故障排查

### 问题：设备端收不到完整消息

**原因**: 可能忘记添加换行符  
**解决**: 确保 App 端 JSON 后有 `\n`

### 问题：数据丢失

**原因**: 分片发送过快  
**解决**: 增加片间延迟到 50ms

### 问题：缓冲区溢出

**原因**: 数据包过大  
**解决**: 减少唤醒词数量或优化数据格式

---

**创建时间**: 2025-11-20  
**版本**: 1.0  
**状态**: ✅ 生产就绪  
**兼容性**: App 端 v1.1.0 + 设备端 (现有代码)

